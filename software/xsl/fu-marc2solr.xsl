<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:oai="http://www.openarchives.org/OAI/2.0/"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:eromm_oai="http://www.eromm.org/eromm_oai_harvester/"
    xmlns:pica="info:srw/schema/5/picaXML-v1.0"
	xmlns:marc="http://www.loc.gov/MARC21/slim"
    exclude-result-prefixes="oai xsi"
    version="1.0">

    <xsl:output method="xml" indent="yes"/>

    <!--
        Parameters
    -->

    <!-- Misc  | default = "unset" -->
    <xsl:param name="timestamp" select="string('unset')"/>
    <xsl:param name="country_code" select="string('unset')"/>
    <xsl:param name="oai_repository_id" select="string('unset')"/>
    <xsl:param name="oai_set_id" select="string('unset')"/>


    <!-- Leading comment -->
    <xsl:template match="/">
        <xsl:comment><xsl:value-of select="string(' ')" />Generated by EROMM-OAI-Harvester @ <xsl:value-of select="concat($timestamp, ' ')"/></xsl:comment>
        <xsl:apply-templates />
    </xsl:template>


    <!-- Grab root -->
    <xsl:template match="oai:OAI-PMH">
        <update>
            <!-- Do new records exist? -->
            <xsl:if test="oai:ListRecords/oai:record/oai:metadata">
                <add overwrite="true">
                   <xsl:apply-templates select="oai:ListRecords/oai:record" mode="add"/>
                </add>
            </xsl:if>

            <!-- Do deleted records exist? (sounds funny) -->
            <xsl:if test="oai:ListRecords/oai:record/oai:header[@status='deleted']">
                <delete>
                   <xsl:apply-templates select="oai:ListRecords/oai:record" mode="delete"/>
                </delete>
             </xsl:if>
        </update>
    </xsl:template>

    <!-- Grab records for indexing and create fields -->
    <xsl:template match="oai:ListRecords/oai:record" mode="add">
        <xsl:if test="not(oai:header[@status='deleted'])">
        <doc>
            <!-- Default fields -->
            <field name="indexed">NOW</field>
            <field name="type">oai</field>

            <!-- Parameter-fields -->
            <field name="country_code">
                <xsl:value-of select="$country_code"/>
            </field>
            <field name="oai_repository_id">
                <xsl:value-of select="$oai_repository_id"/>
            </field>
            <field name="oai_set_id">
                <xsl:value-of select="$oai_set_id"/>
            </field>

            <!-- Record-Header generated fields -->
            <field name="id">
                <xsl:value-of select="oai:header/oai:identifier"/>
            </field>
            <xsl:apply-templates select="oai:header/oai:setSpec"/>


            <!-- Although datestamp is a mandatory element, its not always there... -->
            <xsl:choose>
                <!-- If there is no datestamp, use the datestamp of the preceeding or following records -->
                <xsl:when test="oai:header/oai:datestamp and string-length(oai:header/oai:datestamp) &gt; 0">
                    <xsl:call-template name="parse_datestamp">
                        <xsl:with-param name="value" select="oai:header/oai:datestamp" />
                     </xsl:call-template>
                </xsl:when>
                <xsl:when test="preceding-sibling::oai:record/oai:header/oai:datestamp[node()]">
                    <xsl:call-template name="parse_datestamp">
                        <xsl:with-param name="value" select="preceding-sibling::oai:record/oai:header/oai:datestamp[node()][1]"/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:when test="following-sibling::oai:record/oai:header/oai:datestamp[node()]">
                    <xsl:call-template name="parse_datestamp">
                        <xsl:with-param name="value" select="following-sibling::oai:record/oai:header/oai:datestamp[node()][1]"/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:otherwise>
                    <!-- Even the preceding and following records don't contain a datestamp, use the responseDate (another mandatory element...) -->
                    <xsl:call-template name="parse_datestamp">
                        <xsl:with-param name="value" select="//oai:responseDate"/>
                    </xsl:call-template>
                </xsl:otherwise>
            </xsl:choose>

            <!-- MARC-Metadata generated fields -->
            <xsl:apply-templates select="oai:metadata/marc:record/*"/>
        </doc>
        </xsl:if>
    </xsl:template>


    <!-- Grab records for deletion -->
    <xsl:template match="oai:ListRecords/oai:record" mode="delete">
        <xsl:if test="oai:header[@status='deleted']">
            <id>
                <xsl:value-of select="oai:header/oai:identifier"/>
            </id>
        </xsl:if>
    </xsl:template>


    <!-- Template for setSpec -->
    <xsl:template match="oai:header/oai:setSpec">
        <!-- Ignore eimpty setSpec elements (GDZ...) -->
        <xsl:if test="string-length(.) > 0">
            <field name="oai_setspec">
                <xsl:value-of select="."/>
            </field>
        </xsl:if>
    </xsl:template>


    <!-- Template for datestamp -->
    <xsl:template name="parse_datestamp">
        <xsl:param name="value" select="unset" />
        <field name="oai_datestamp">
            <!-- OAI allows datestamp with and without time (e.g. 2011-01-01 or 2011-01-01T00:00:00Z)
                 Solr requires with time, so it has to be appended if missing -->
            <xsl:choose>
               <!-- If the value is 10 chars, time is missing -->
                <xsl:when test="string-length($value) = 10">
                    <xsl:value-of select="concat($value, 'T00:59:59Z')"/>
              </xsl:when>
              <xsl:otherwise>
                  <xsl:value-of select="$value"/>
              </xsl:otherwise>
            </xsl:choose>
        </field>
    </xsl:template>


    <!-- Template for URLs -->
    <xsl:template match="eromm_oai:oai_url">
        <field name="oai_url">
            <xsl:value-of select="."/>
        </field>
    </xsl:template>

	<xsl:template match="marc:leader"/>


	<xsl:template match="marc:controlfield">
		<xsl:choose>
			<xsl:when test="@tag='001'">
				<field name="identifier">
					<xsl:value-of select="."/>
				</field>
			</xsl:when>
		</xsl:choose>
	</xsl:template>


    <xsl:template match="marc:datafield">
    	<xsl:variable name="field" select="@tag"/>

		<xsl:choose>
			<xsl:when test="@tag='245' and subfield[@code='a']">
				<field name="title">
					<xsl:value-of select="marc:subfield[@code='a']"/>
				</field>
			</xsl:when>
			<xsl:when test="@tag='260'">
				<xsl:if test="marc:subfield[@code='a'] or marc:subfield[@code='b']">
					<field name="publisher">
						<xsl:if test="marc:subfield[@code='b']">
							<xsl:value-of select="marc:subfield[@code='b']"/>
						</xsl:if>
						<xsl:if test="marc:subfield[@code='a'] and marc:subfield[@code='b']">
							<xsl:text>, </xsl:text>
						</xsl:if>
						<xsl:if test="marc:subfield[@code='a']">
							<xsl:value-of select="marc:subfield[@code='a']"/>
						</xsl:if>
					</field>
				</xsl:if>
				<xsl:if test="marc:subfield[@code='c']">
					<field name="date">
						<xsl:value-of select="marc:subfield[@code='c']"/>
					</field>
				</xsl:if>
			</xsl:when>
			<xsl:when test="@tag='362'">
				<field name="coverage">
					<xsl:value-of select="marc:subfield[@code='a']"/>
				</field>
			</xsl:when>
			<xsl:when test="@tag='310'">
				<field name="description">
					<xsl:value-of select="marc:subfield[@code='a']"/>
				</field>
			</xsl:when>
			<xsl:when test="@tag='247'">
				<field name="description">
					<xsl:value-of select="marc:subfield[@code='a']"/>
				</field>
			</xsl:when>
			<xsl:when test="@tag='785'">
				<field name="description">
					<xsl:value-of select="marc:subfield[@code='t']"/>
				</field>
			</xsl:when>
			<xsl:when test="@tag='041'">
				<field name="language">
					<xsl:value-of select="marc:subfield[@code='a']"/>
				</field>
			</xsl:when>
			
		</xsl:choose>

    </xsl:template>





	<xsl:template name="splitter">
		<xsl:param name="list"/>
		<xsl:param name="separator"/>
		<xsl:param name="metadataType"/>
		<xsl:param name="minLength"/>
		<xsl:param name="maxLength"/>

		<xsl:variable name="firstItem">
			<xsl:choose>
				<xsl:when test="contains($list, $separator)">
					<xsl:value-of select="normalize-space(substring-before($list, $separator))"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="normalize-space($list)"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>

		<xsl:variable name="remainingItems" select="substring-after($list, $separator)"/>


		<xsl:if test="$firstItem">
			<xsl:if test="(not($minLength) or string-length($firstItem) = $minLength)
							and (not($maxLength) or string-length($firstItem) = $maxLength)">
				<field>
					<xsl:attribute name="name">
						<xsl:value-of select="$metadataType"/>
					</xsl:attribute>
					<xsl:value-of select="$firstItem"/>
				</field>
			</xsl:if>
		</xsl:if>

		<xsl:if test="$remainingItems">
			<xsl:call-template name="splitter">
				<xsl:with-param name="list" select="$remainingItems"/>
				<xsl:with-param name="separator" select="$separator"/>
				<xsl:with-param name="metadataType" select="$metadataType"/>
			</xsl:call-template>
		</xsl:if>
	</xsl:template>

</xsl:stylesheet>
